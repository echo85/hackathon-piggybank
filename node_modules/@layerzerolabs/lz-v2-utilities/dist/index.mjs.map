{"version":3,"sources":["../src/utils/hex.ts","../src/utils/precrime.ts","../src/utils/parse-error.ts","../src/options/options.ts","../src/model/packet.ts","../src/codec/packet-v1-codec.ts","../src/codec/packet-serializer.ts","../src/commandCodec/commandCodec.ts"],"names":["OptionType","solidityPack","WorkerId","ExecutorOptionType","VerifierOptionType","arrayify","hexlify","BigNumber","TimestampBlockConfiguration","ResolverType","ComputeSetting","ComputeType"],"mappings":"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","file":"index.mjs","sourcesContent":["import { getAddress } from '@ethersproject/address'\nimport { arrayify, hexZeroPad, hexlify } from '@ethersproject/bytes'\nimport base58 from 'bs58'\n\n/**\n * Pads a hexadecimal address to 32 bytes.\n *\n * @param addr - The address to pad.\n *\n * @returns {string} The padded address.\n */\nexport function hexZeroPadTo32(addr: string): string {\n    return hexZeroPad(addr, 32)\n}\n\n/**\n * Converts a bytes32 value to an Ethereum address.\n *\n * @param bytes32 - The bytes32 value.\n *\n * @returns {string} The Ethereum address.\n */\nexport function bytes32ToEthAddress(bytes32: string | Uint8Array): string {\n    if (bytes32 instanceof Uint8Array) {\n        bytes32 = hexlify(bytes32)\n    }\n    return getAddress(bytes32.slice(-40))\n}\n\n/**\n * Trims the '0x' prefix from a hexadecimal string.\n *\n * @param str - The hexadecimal string.\n *\n * @returns {string} The trimmed string.\n */\nexport function trim0x(str: string): string {\n    return str.replace(/^0x/, '')\n}\n\n/**\n * Converts an address to bytes32.\n *\n * @param address - The address to convert.\n *\n * @returns {Uint8Array} The bytes32 representation of the address.\n *\n * @throws {Error} If the address is invalid.\n */\nexport function addressToBytes32(address: string): Uint8Array {\n    if (isSolanaAddress(address)) {\n        return base58.decode(address)\n    } else if (address.startsWith('0x') && address.length <= 66) {\n        return arrayify(hexZeroPadTo32(address))\n    }\n    throw new Error('Invalid address')\n}\n\nconst solanaAddressRegex = /^([1-9A-HJ-NP-Za-km-z]{32,44})$/\n\n/**\n * Checks if an address is a Solana address.\n *\n * @param address - The address to check.\n *\n * @returns {boolean} True if the address is a Solana address, false otherwise.\n */\nexport function isSolanaAddress(address: string): boolean {\n    return solanaAddressRegex.test(address)\n}\n\nconst aptosAddressRegex = /^(0x)?[0-9a-fA-F]{1,64}$/\n\n/**\n * Checks if an address is an Aptos address.\n *\n * @param address - The address to check.\n *\n * @returns {boolean} True if the address is an Aptos address, false otherwise. Could be short address.\n */\nexport function isAptosAddress(address: string): boolean {\n    return aptosAddressRegex.test(address)\n}\n\nconst initiaAddressRegex = /^0x[a-fA-F0-9]{1,64}$/\n\n/**\n * Checks if an address is an Initia address. Could be short address.\n *\n * @param address - The address to check.\n *\n * @returns {boolean} True if the address is an Initia address, false otherwise.\n */\nexport function isInitiaAddress(address: string): boolean {\n    return initiaAddressRegex.test(address)\n}\n","import { PreCrimePeer, PrecrimeConfig, PrecrimeConfigV1, PrecrimeConfigV2 } from '../model'\n\nimport { trim0x } from './hex'\n\nconst CONFIG_VERSION_OFFSET = 0\nconst MAX_BATCH_SIZE_OFFSET = 2\nconst NUMBER_OF_PEERS_OFFSET = 10\nconst PEERS_OFFSET = 12\n\n/**\n * Parses the precrime configuration string.\n *\n * @param precrimeConfig - The precrime configuration string.\n *\n * @returns {PrecrimeConfig} The parsed precrime configuration.\n *\n * @throws {Error} If the precrime config version is unsupported.\n */\nexport function parsePrecrimeConfig(precrimeConfig: string): PrecrimeConfig {\n    const data = trim0x(precrimeConfig)\n    const version = parseInt(data.slice(0, 4), 16)\n    if (version === 1) {\n        return parsePrecrimeConfigV1(precrimeConfig)\n    } else if (version === 2) {\n        return parsePrecrimeConfigV2(precrimeConfig)\n    }\n    throw new Error(`Unsupported precrime config version: ${version}`)\n}\n\n/**\n * Parses the precrime configuration string for version 1.\n *\n * @param precrimeConfig - The precrime configuration string.\n *\n * @returns {PrecrimeConfigV1} The parsed precrime configuration for version 1.\n */\nfunction parsePrecrimeConfigV1(precrimeConfig: string): PrecrimeConfigV1 {\n    const data = trim0x(precrimeConfig)\n    const version = parseInt(data.slice(0, 4), 16)\n    const maxBatchSize = parseInt(data.slice(4, 20), 16)\n    const remoteChainsLength = parseInt(data.slice(20, 84), 16)\n    const remoteChainsBytes = data.slice(84, 84 + remoteChainsLength * 64)\n    const remoteAddressesBytes = data.slice(\n        84 + remoteChainsLength * 64,\n        84 + remoteChainsLength * 64 + remoteChainsLength * 64\n    )\n\n    const remoteChainsBytesArray: number[] = []\n    const remoteAddressesBytesArray: string[] = []\n    let start = 0\n    let end = 64\n    for (let i = 0; i < remoteChainsLength; i++) {\n        remoteChainsBytesArray.push(parseInt(remoteChainsBytes.slice(start, end), 16))\n        remoteAddressesBytesArray.push(`0x${remoteAddressesBytes.slice(start, end)}`)\n        start += 64\n        end += 64\n    }\n    return { version, maxBatchSize, remoteEids: remoteChainsBytesArray, remoteAddresses: remoteAddressesBytesArray }\n}\n\n/**\n * Parses the precrime configuration string for version 2.\n *\n * @param precrimeConfig - The precrime configuration string.\n *\n * @returns {PrecrimeConfigV2} The parsed precrime configuration for version 2.\n */\nfunction parsePrecrimeConfigV2(precrimeConfig: string): PrecrimeConfigV2 {\n    const buffer = Buffer.from(trim0x(precrimeConfig), 'hex')\n    const version = buffer.readUInt16BE(CONFIG_VERSION_OFFSET)\n    const maxBatchSize = buffer.readBigUint64BE(MAX_BATCH_SIZE_OFFSET)\n    const peers = new Array<PreCrimePeer>()\n    if (buffer.length > NUMBER_OF_PEERS_OFFSET) {\n        const numOfPeers = buffer.readUInt16BE(NUMBER_OF_PEERS_OFFSET)\n        for (let i = 0; i < numOfPeers; i++) {\n            const offset = PEERS_OFFSET + i * (4 + 2 * 32)\n            const eid = buffer.readUInt32BE(offset)\n            const preCrimeAddress = '0x' + buffer.slice(offset + 4, offset + 4 + 32).toString('hex')\n            const oappAddress = '0x' + buffer.slice(offset + 4 + 32, offset + 4 + 32 + 32).toString('hex')\n            peers.push({\n                eid,\n                preCrimeAddress,\n                oappAddress,\n            })\n        }\n    }\n    return {\n        version,\n        maxBatchSize,\n        peers,\n    }\n}\n","import { type Interface, defaultAbiCoder } from '@ethersproject/abi'\n\n/**\n * Parses the error data.\n *\n * @param errorData - The error data string.\n * @param intf - The optional interface to parse the error.\n *\n * @returns {ReturnType<Interface['parseError']> | string | number | undefined} The parsed error.\n */\nexport const parseError = (\n    errorData: string,\n    intf?: Interface\n): ReturnType<Interface['parseError']> | string | number | undefined => {\n    const buildInError = parseBuildInError(errorData)\n    if (buildInError !== undefined) {\n        return buildInError\n    }\n\n    if (intf) {\n        try {\n            return intf.parseError(errorData)\n        } catch (e) {\n            console.error(e)\n        }\n    }\n}\n\n/**\n * Parses built-in errors.\n *\n * @param errorData - The error data string.\n *\n * @returns {string | number | undefined} The parsed built-in error.\n */\nfunction parseBuildInError(errorData: string): string | number | undefined {\n    if (errorData.startsWith('0x08c379a0')) {\n        // decode Error(string)\n\n        const content = `0x${errorData.substring(10)}`\n        const reason = defaultAbiCoder.decode(['string'], content)\n\n        return reason[0] as string // reason: string; for standard revert error string\n    }\n\n    if (errorData.startsWith('0x4e487b71')) {\n        // decode Panic(uint)\n        const content = `0x${errorData.substring(10)}`\n        const code = defaultAbiCoder.decode(['uint'], content)\n\n        return code[0] as number\n    }\n\n    if (errorData === '0x') {\n        return ''\n    }\n\n    return undefined\n}\n","/* eslint-disable @typescript-eslint/consistent-return, @typescript-eslint/no-unsafe-enum-comparison */\n\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { arrayify, hexlify } from '@ethersproject/bytes'\nimport { pack as solidityPack } from '@ethersproject/solidity'\nimport invariant from 'tiny-invariant'\n\nimport { addressToBytes32, trim0x } from '../utils'\n\n// gasLimit input type\nexport type GasLimit = string | number | bigint\n\n// native drop input type\nexport type NativeDrop = string | number | bigint\n\nexport type DataSize = string | number | bigint\n\n/**\n * Enumerates the supported option types.\n */\nexport enum OptionType {\n    /**\n     * Allows the specification of the gas allowance for the remote executor transaction, measured in destination gas\n     * units.\n     *\n     * Format:\n     * bytes  [2     32      ]\n     * fields [type  extraGas]\n     */\n    TYPE_1 = 1,\n\n    /**\n     * Combines the functionality of TYPE_1 along with destination gas drop to a remote address.\n     *\n     * Format:\n     * bytes  [2     32        32            bytes[]         ]\n     * fields [type  extraGas  dstNativeAmt  dstNativeAddress]\n     */\n    TYPE_2 = 2,\n\n    /**\n     * EndpointV2 specific options.\n     */\n    TYPE_3 = 3,\n}\n\nconst MAX_UINT_128 = BigNumber.from('0xffffffffffffffffffffffffffffffff')\n\n/**\n * Builds OptionsType.TYPE_1.\n *\n * @param {GasLimit} _extraGas The gas allowance for the remote executor transaction, measured in destination gas units.\n */\nexport function optionsType1(_extraGas: GasLimit): string {\n    const extraGas = BigNumber.from(_extraGas)\n    invariant(extraGas.lte(MAX_UINT_128), 'extraGas should be less than MAX_UINT_128')\n    return solidityPack(['uint16', 'uint256'], [OptionType.TYPE_1, extraGas])\n}\n\n/**\n * Builds OptionsType.TYPE_2.\n *\n * @param {GasLimit} _extraGas The gas allowance for the remote executor transaction, measured in destination gas units.\n * @param {NativeDrop} _dstNativeAmt The amount of native token to be sent to the destination chain.\n * @param {string} _dstNativeAddress The destination address of _dstNativeAmt.\n */\nexport function optionsType2(_extraGas: GasLimit, _dstNativeAmt: NativeDrop, _dstNativeAddress: string): string {\n    const extraGas = BigNumber.from(_extraGas)\n    invariant(extraGas.lte(MAX_UINT_128), 'extraGas should be less than MAX_UINT_128')\n    const dstNativeAmt = BigNumber.from(_dstNativeAmt)\n    invariant(dstNativeAmt.lte(MAX_UINT_128), 'dstNativeAmt should be less than MAX_UINT_128')\n    return solidityPack(\n        ['uint16', 'uint256', 'uint256', 'bytes'],\n        [OptionType.TYPE_2, BigNumber.from(extraGas), BigNumber.from(dstNativeAmt), _dstNativeAddress]\n    )\n}\n\n/**\n * Enumerates the supported worker IDs.\n */\nexport enum WorkerId {\n    /**\n     * Executor worker ID.\n     */\n    EXECUTOR = 1,\n\n    /**\n     * Verifier worker ID.\n     */\n    VERIFIER = 2,\n\n    /**\n     * Treasury worker ID.\n     */\n    TREASURY = 255,\n}\n\n/**\n * Interface representing worker options.\n */\nexport interface WorkerOptions {\n    /**\n     * The worker ID.\n     */\n    workerId: number // uint8\n\n    /**\n     * The options.\n     */\n    options: Option[] // toBytes: num(uint8),[type(uint8),size(uint16),data],[type(uint8),size(uint16),data],[type(uint8),size(uint16),data]...\n}\n\n/**\n * Interface representing an option.\n */\nexport interface Option {\n    /**\n     * The option type.\n     */\n    type: number // uint8\n\n    /**\n     * The option parameters.\n     */\n    params: string // bytes\n}\n\n/**\n * Interface representing a verifier option.\n */\nexport type VerifierOption = Option & {\n    /**\n     * The verifier index.\n     */\n    index: number // uint8\n}\n\n/**\n * Enumerates the supported executor option types.\n */\nexport enum ExecutorOptionType {\n    /**\n     * LZ_RECEIVE option type.\n     */\n    LZ_RECEIVE = 1,\n\n    /**\n     * NATIVE_DROP option type.\n     */\n    NATIVE_DROP = 2,\n\n    /**\n     * COMPOSE option type.\n     */\n    COMPOSE = 3,\n\n    /**\n     * ORDERED option type.\n     */\n    ORDERED = 4,\n\n    /**\n     * LZ_READ option type.\n     */\n    LZ_READ = 5,\n}\n\n/**\n * Enumerates the supported verifier option types.\n */\nexport enum VerifierOptionType {\n    /**\n     * PRECRIME option type.\n     */\n    PRECRIME = 1,\n}\n\n/**\n * ExecutorLzReceiveOption type.\n */\nexport interface ExecutorLzReceiveOption {\n    /**\n     * The gas limit.\n     */\n    gas: bigint\n\n    /**\n     * The value.\n     */\n    value: bigint\n}\n\n/**\n * ExecutorLzReadOption type.\n */\nexport interface ExecutorLzReadOption {\n    /**\n     * The gas limit.\n     */\n    gas: bigint\n\n    /**\n     * The data size.\n     */\n    dataSize: bigint\n\n    /**\n     * The value.\n     */\n    value: bigint\n}\n\n/**\n * ExecutorNativeDropOption type.\n */\nexport type ExecutorNativeDropOption = { amount: bigint; receiver: string }[]\n\n/**\n * ComposeOption type.\n */\nexport type ComposeOption = { index: number; gas: bigint; value: bigint }[]\n\n/**\n * Options builder, available only for EndpointV2.\n */\nexport class Options {\n    protected workerOptions: WorkerOptions[] = []\n\n    // dissuade public instantiation\n    protected constructor() {}\n\n    /**\n     * Create a new options instance.\n     */\n    public static newOptions(): Options {\n        return new Options()\n    }\n\n    /**\n     * Create an options instance from a hex string.\n     * @param {string} optionsHex The hex string to decode.\n     */\n    public static fromOptions(optionsHex: string): Options {\n        const options = new Options()\n        const optionsBytes = arrayify(optionsHex)\n        // 0-2 bytes is options type\n        const optionsType = BigNumber.from(optionsBytes.slice(0, 2)).toNumber()\n        if (optionsType === OptionType.TYPE_3) {\n            let cursor = 2\n            while (cursor < optionsBytes.byteLength) {\n                const workerId = BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                cursor += 1\n\n                const size = BigNumber.from(optionsBytes.slice(cursor, cursor + 2)).toNumber()\n                cursor += 2\n\n                if (workerId === WorkerId.EXECUTOR) {\n                    const optionType = BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                    cursor += 1\n                    const params = optionsBytes.slice(cursor, cursor + size - 1)\n                    cursor += size - 1\n                    options.addOption(workerId, { type: optionType, params: hexlify(params) })\n                } else if (workerId === WorkerId.VERIFIER) {\n                    const verifierIdx = BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                    cursor += 1\n                    const optionType = BigNumber.from(optionsBytes.slice(cursor, cursor + 1)).toNumber()\n                    cursor += 1\n                    const params = optionsBytes.slice(cursor, cursor + size - 2)\n                    cursor += size - 2\n                    const option: VerifierOption = {\n                        type: optionType,\n                        index: verifierIdx,\n                        params: hexlify(params),\n                    }\n                    options.addOption(workerId, option)\n                }\n                // TODO - other workerId\n            }\n        } else if (optionsType === OptionType.TYPE_2) {\n            const extraGas = BigNumber.from(optionsBytes.slice(2, 34)).toBigInt()\n            const dstNativeAmt = BigNumber.from(optionsBytes.slice(34, 66)).toBigInt()\n            const dstNativeAddress = hexlify(optionsBytes.slice(66, optionsBytes.byteLength))\n            options.addExecutorLzReceiveOption(extraGas).addExecutorNativeDropOption(dstNativeAmt, dstNativeAddress)\n        } else if (optionsType === OptionType.TYPE_1) {\n            const extraGas = BigNumber.from(optionsBytes.slice(2, 34)).toBigInt()\n            options.addExecutorLzReceiveOption(extraGas)\n        }\n\n        return options\n    }\n\n    /**\n     * Add ExecutorOptionType.LZ_RECEIVE option.\n     * @param {GasLimit} gasLimit\n     * @param {NativeDrop} nativeDrop\n     */\n    public addExecutorLzReceiveOption(gasLimit: GasLimit, nativeDrop: NativeDrop = 0): this {\n        const gasLimitBN = BigNumber.from(gasLimit)\n        invariant(gasLimitBN.lte(MAX_UINT_128), \"gasLimit shouldn't be greater than MAX_UINT_128\")\n        const nativeDropBN = BigNumber.from(nativeDrop)\n        invariant(nativeDropBN.lte(MAX_UINT_128), \"value shouldn't be greater than MAX_UINT_128\")\n        this.addOption(WorkerId.EXECUTOR, {\n            type: ExecutorOptionType.LZ_RECEIVE,\n            params: nativeDropBN.eq(0)\n                ? solidityPack(['uint128'], [gasLimitBN])\n                : solidityPack(['uint128', 'uint128'], [gasLimitBN, nativeDropBN]),\n        })\n        return this\n    }\n\n    /**\n     * Add ExecutorOptionType.NATIVE_DROP option.\n     * @param {NativeDrop} nativeDrop\n     * @param {string} receiver\n     */\n    public addExecutorNativeDropOption(nativeDrop: NativeDrop, receiver: string): this {\n        const amountBN = BigNumber.from(nativeDrop)\n        invariant(amountBN.lte(MAX_UINT_128), \"nativeDrop shouldn't be greater than MAX_UINT_128\")\n        this.addOption(WorkerId.EXECUTOR, {\n            type: ExecutorOptionType.NATIVE_DROP,\n            params: solidityPack(['uint128', 'bytes32'], [amountBN, addressToBytes32(receiver)]),\n        })\n        return this\n    }\n\n    /**\n     * Add ExecutorOptionType.COMPOSE option.\n     * @param {number} index\n     * @param {GasLimit} gasLimit\n     * @param {NativeDrop} nativeDrop\n     */\n    public addExecutorComposeOption(index: number, gasLimit: GasLimit, nativeDrop: NativeDrop = 0): this {\n        const gasLimitBN = BigNumber.from(gasLimit)\n        invariant(gasLimitBN.lte(MAX_UINT_128), \"gasLimit shouldn't be greater than MAX_UINT_128\")\n        const nativeDropBN = BigNumber.from(nativeDrop)\n        invariant(nativeDropBN.lte(MAX_UINT_128), \"nativeDrop shouldn't be greater than MAX_UINT_128\")\n        const option = nativeDropBN.gt(0)\n            ? {\n                  type: ExecutorOptionType.COMPOSE,\n                  params: solidityPack(['uint16', 'uint128', 'uint128'], [index, gasLimitBN, nativeDropBN]),\n              }\n            : {\n                  type: ExecutorOptionType.COMPOSE,\n                  params: solidityPack(['uint16', 'uint128'], [index, gasLimitBN]),\n              }\n\n        this.addOption(WorkerId.EXECUTOR, option)\n        return this\n    }\n\n    /**\n     * Add ExecutorOptionType.ORDERED option.\n     *\n     * @returns {this} The options instance.\n     */\n    public addExecutorOrderedExecutionOption(): this {\n        this.addOption(WorkerId.EXECUTOR, {\n            type: ExecutorOptionType.ORDERED,\n            params: '0x',\n        })\n        return this\n    }\n\n    /**\n     * Add ExecutorOptionType.LZ_READ option.\n     *\n     * @param {GasLimit} gasLimit - The gas limit.\n     * @param {DataSize} dataSize - The data size.\n     * @param {NativeDrop} [nativeDrop=0] - The native drop.\n     * @returns {this} The options instance.\n     */\n    public addExecutorLzReadOption(gasLimit: GasLimit, dataSize: DataSize, nativeDrop: NativeDrop = 0): this {\n        const gasLimitBN = BigNumber.from(gasLimit)\n        const dataSizeBN = BigNumber.from(dataSize)\n        const nativeDropBN = BigNumber.from(nativeDrop)\n        this.addOption(WorkerId.EXECUTOR, {\n            type: ExecutorOptionType.LZ_READ,\n            params: nativeDropBN.eq(0)\n                ? solidityPack(['uint128', 'uint32'], [gasLimitBN, dataSizeBN])\n                : solidityPack(['uint128', 'uint32', 'uint128'], [gasLimitBN, dataSizeBN, nativeDropBN]),\n        })\n        return this\n    }\n\n    /**\n     * Add VerifierOptionType.PRECRIME option.\n     *\n     * @param {number} verifierIdx - The verifier index.\n     * @returns {this} The options instance.\n     */\n    public addVerifierPrecrimeOption(verifierIdx: number): this {\n        const option: VerifierOption = {\n            type: VerifierOptionType.PRECRIME,\n            index: verifierIdx,\n            params: '0x',\n        }\n        this.addOption(WorkerId.VERIFIER, option)\n        return this\n    }\n\n    /**\n     * Serialize Options to hex string.\n     *\n     * @returns {string} The serialized hex string.\n     */\n    public toHex(): string {\n        // output encoded hex, type(uint16)\n        let hex = solidityPack(['uint16'], [OptionType.TYPE_3])\n        this.workerOptions.forEach((w) => {\n            for (const option of w.options) {\n                if (w.workerId === WorkerId.EXECUTOR) {\n                    hex += trim0x(\n                        solidityPack(\n                            ['uint8', 'uint16', 'uint8', 'bytes'],\n                            [w.workerId, trim0x(option.params).length / 2 + 1, option.type, option.params]\n                        )\n                    )\n                } else if (w.workerId === WorkerId.VERIFIER) {\n                    const verifierOption = option as VerifierOption\n                    hex += trim0x(\n                        solidityPack(\n                            ['uint8', 'uint16', 'uint8', 'uint8', 'bytes'],\n                            [\n                                w.workerId,\n                                trim0x(option.params).length / 2 + 2,\n                                verifierOption.index,\n                                verifierOption.type,\n                                verifierOption.params,\n                            ]\n                        )\n                    )\n                }\n                // TODO other workerId\n            }\n        })\n        return hex\n    }\n\n    /**\n     * Serialize Options to Uint8Array.\n     *\n     * @returns {Uint8Array} The serialized Uint8Array.\n     */\n    public toBytes(): Uint8Array {\n        return arrayify(this.toHex())\n    }\n\n    /**\n     * Adds an option to the specified worker.\n     *\n     * @param {number} workerId - The ID of the worker.\n     * @param {Option} option - The option to add.\n     */\n    private addOption(workerId: number, option: Option): void {\n        const worker = this.workerOptions.find((w) => w.workerId === workerId)\n        if (worker) {\n            worker.options.push(option)\n        } else {\n            this.workerOptions.push({ workerId, options: [option] })\n        }\n    }\n\n    /**\n     * Decode ExecutorOptionType.LZ_RECEIVE option. Returns undefined if the option is not present.\n     *\n     * @returns {ExecutorLzReceiveOption | undefined} The decoded option or undefined if not present.\n     */\n    public decodeExecutorLzReceiveOption(): ExecutorLzReceiveOption | undefined {\n        let options = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.LZ_RECEIVE)\n        if (options === undefined || (Array.isArray(options) && options.length === 0)) {\n            return\n        }\n        let totalGas = BigNumber.from(0).toBigInt()\n        let totalValue = BigNumber.from(0).toBigInt()\n        options = Array.isArray(options) ? options : [options]\n        for (const option of options) {\n            const buffer = Buffer.from(trim0x(option.params), 'hex')\n            const gas = BigNumber.from(buffer.subarray(0, 16)).toBigInt()\n            const value = BigNumber.from(buffer.length === 16 ? 0 : buffer.subarray(16, 32)).toBigInt()\n            totalGas = totalGas + gas\n            totalValue = totalValue + value\n        }\n\n        return { gas: totalGas, value: totalValue }\n    }\n\n    /**\n     * Decode ExecutorOptionType.NATIVE_DROP options. Returns undefined if the options is not present.\n     *\n     * @returns {ExecutorNativeDropOption} The decoded options.\n     */\n    public decodeExecutorNativeDropOption(): ExecutorNativeDropOption {\n        const options = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.NATIVE_DROP) as Option[]\n        if (!options || options.length === 0) {\n            return []\n        }\n\n        const results = options.reduce((acc: { [key: string]: { amount: bigint; receiver: string } }, cur: Option) => {\n            const buffer = Buffer.from(trim0x(cur.params), 'hex')\n            const amount = BigNumber.from(buffer.subarray(0, 16)).toBigInt()\n            const receiver = hexlify(buffer.subarray(16, 48))\n            if (acc[receiver]) {\n                acc[receiver].amount = acc[receiver].amount + amount\n            } else {\n                acc[receiver] = { amount, receiver }\n            }\n            return acc\n        }, {})\n        return Object.values(results)\n    }\n\n    /**\n     * Decode ExecutorOptionType.COMPOSE options. Returns undefined if the options is not present.\n     *\n     * @returns {ComposeOption} The decoded options.\n     */\n    public decodeExecutorComposeOption(): ComposeOption {\n        const options = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.COMPOSE) as Option[]\n        if (!options || options.length === 0) {\n            return []\n        }\n        const results = options.reduce(\n            (acc: { [key: number]: { index: number; gas: bigint; value: bigint } }, cur: Option) => {\n                const buffer = Buffer.from(trim0x(cur.params), 'hex')\n                const index = BigNumber.from(buffer.subarray(0, 2)).toNumber()\n                const gas = BigNumber.from(buffer.subarray(2, 18)).toBigInt()\n                const value = (\n                    buffer.length === 34 ? BigNumber.from(buffer.subarray(18, 34)) : BigNumber.from(0)\n                ).toBigInt()\n                if (acc[index]) {\n                    acc[index].gas = acc[index].gas + gas\n                    acc[index].value = acc[index].value + value\n                } else {\n                    acc[index] = { index, gas, value }\n                }\n                return acc\n            },\n            {}\n        )\n        return Object.values(results)\n    }\n\n    /**\n     * Decode ExecutorOptionType.ORDERED options. Returns undefined if the options is not present.\n     *\n     * @returns {boolean} True if the option is present, false otherwise.\n     */\n    public decodeExecutorOrderedExecutionOption(): boolean {\n        const option = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.ORDERED)\n        return option !== undefined\n    }\n\n    /**\n     * Decodes ExecutorOptionType.LZ_READ options. Returns undefined if the option is not present.\n     *\n     * @returns {ExecutorLzReadOption | undefined} The decoded ExecutorLzReadOption or undefined if not present.\n     */\n    public decodeExecutorLzReadOption(): ExecutorLzReadOption | undefined {\n        let options = this.findOptions(WorkerId.EXECUTOR, ExecutorOptionType.LZ_READ)\n        if (options === undefined || (Array.isArray(options) && options.length === 0)) {\n            return undefined\n        }\n        let totalGas = BigNumber.from(0).toBigInt()\n        let dataSize = BigNumber.from(0).toBigInt()\n        let totalValue = BigNumber.from(0).toBigInt()\n        options = Array.isArray(options) ? options : [options]\n        for (const option of options) {\n            const buffer = Buffer.from(trim0x(option.params), 'hex')\n            const gas = BigNumber.from(buffer.subarray(0, 16)).toBigInt() // uint128\n            const size = BigNumber.from(buffer.subarray(16, 20)).toBigInt() // uint32\n            const value = BigNumber.from(buffer.length === 20 ? 0 : buffer.subarray(20, 36)).toBigInt() // uint128\n            totalGas = totalGas + gas\n            dataSize = dataSize + size\n            totalValue = totalValue + value\n        }\n\n        return { gas: totalGas, dataSize, value: totalValue }\n    }\n\n    /**\n     * Finds options for a given worker and option type.\n     *\n     * @param {number} workerId - The ID of the worker.\n     * @param {number} optionType - The type of the option.\n     * @returns {Option[] | Option | undefined} The found options or undefined if not present.\n     */\n    private findOptions(workerId: number, optionType: number): Option[] | Option | undefined {\n        const worker = this.workerOptions.find((w) => w.workerId === workerId)\n        if (worker) {\n            if (optionType === ExecutorOptionType.ORDERED) {\n                return worker.options.find((o) => o.type === optionType)\n            }\n            return worker.options.filter((o) => o.type === optionType)\n        }\n    }\n\n    /**\n     * Finds a VerifierOption by verifier index and option type. Returns undefined if the option is not present.\n     *\n     * @param {number} verifierIdx - The index of the verifier.\n     * @param {number} optionType - The type of the option.\n     * @returns {VerifierOption | undefined} The found VerifierOption or undefined if not present.\n     */\n    public findVerifierOption(verifierIdx: number, optionType: number): VerifierOption | undefined {\n        const worker = this.workerOptions.find((w) => w.workerId === WorkerId.VERIFIER)\n        if (worker) {\n            const opt = worker.options.find((o) => o.type === optionType && (o as VerifierOption).index === verifierIdx)\n            if (opt) {\n                return opt as VerifierOption\n            }\n        }\n    }\n}\n","/**\n * Path information for a packet.\n */\nexport interface PacketPath {\n    /**\n     * Source EID.\n     */\n    srcEid: number\n    /**\n     * Sender address.\n     */\n    sender: string\n    /**\n     * Destination EID.\n     */\n    dstEid: number\n    /**\n     * Receiver address.\n     */\n    receiver: string\n}\n\n/**\n * Header information for a packet.\n *\n * @extends PacketPath\n */\nexport type PacketHeader = {\n    /**\n     * Version number.\n     */\n    version: number\n    /**\n     * Nonce value.\n     */\n    nonce: string\n} & PacketPath\n\n/**\n * Packet structure.\n *\n * @extends PacketHeader\n */\nexport type Packet = PacketHeader & {\n    /**\n     * GUID of the packet.\n     */\n    guid: string\n    /**\n     * Message content.\n     */\n    message: string\n    /**\n     * Derived payload.\n     *\n     * payload = guid + message\n     */\n    payload: string // payload = guid + message\n}\n\n/**\n * Origin information for a message.\n */\nexport interface MessageOrigin {\n    /**\n     * Source EID.\n     */\n    srcEid: number\n    /**\n     * Sender address.\n     */\n    sender: string\n    /**\n     * Nonce value.\n     */\n    nonce: string\n}\n\n/**\n * Converts a packet to a message origin.\n *\n * @param {Packet} packet - The packet to convert.\n *\n * @returns {MessageOrigin} The message origin.\n */\nexport function packetToMessageOrigin(packet: Packet): MessageOrigin {\n    return {\n        srcEid: packet.srcEid,\n        sender: packet.sender,\n        nonce: packet.nonce,\n    }\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { keccak256 } from '@ethersproject/keccak256'\nimport { pack as solidityPack } from '@ethersproject/solidity'\n\nimport { Packet, PacketHeader } from '../model'\nimport { addressToBytes32, bytes32ToEthAddress, trim0x } from '../utils'\n\n// header (version + path + guid)\n// version\nconst PACKET_VERSION_OFFSET = 0\n//    nonce\nconst NONCE_OFFSET = 1\n//    path\nconst SRC_CHAIN_OFFSET = 9\nconst SRC_ADDRESS_OFFSET = 13\nconst DST_CHAIN_OFFSET = 45\nconst DST_ADDRESS_OFFSET = 49\n// payload (guid + message)\nconst GUID_OFFSET = 81 // keccak256(nonce + path)\nconst MESSAGE_OFFSET = 113\n\n/**\n * Class representing the PacketV1Codec.\n */\nexport class PacketV1Codec {\n    /**\n     * Buffer to hold the encoded packet data.\n     */\n    buffer: Buffer\n\n    /**\n     * Create a PacketV1Codec instance from an encoded payload string.\n     *\n     * @param payloadEncoded - The encoded payload string.\n     * @returns A new PacketV1Codec instance.\n     */\n    static from(payloadEncoded: string): PacketV1Codec {\n        return new PacketV1Codec(payloadEncoded)\n    }\n\n    /**\n     * Create a PacketV1Codec instance from a byte array.\n     *\n     * @param payload - The byte array representing the payload.\n     * @returns A new PacketV1Codec instance.\n     */\n    static fromBytes(payload: Uint8Array): PacketV1Codec {\n        return new PacketV1Codec('0x' + Buffer.from(payload).toString('hex'))\n    }\n\n    /**\n     * Constructor for the PacketV1Codec class.\n     *\n     * @param payloadEncoded - The encoded payload string.\n     */\n    protected constructor(payloadEncoded: string) {\n        this.buffer = Buffer.from(trim0x(payloadEncoded), 'hex')\n    }\n\n    /**\n     * Encode a packet to a hex string.\n     *\n     * @param packet - The packet to encode.\n     * @returns The encoded packet as a hex string.\n     */\n    static encode(packet: Packet): string {\n        const buff = this.encodeBytes(packet)\n        return '0x' + Buffer.from(buff).toString('hex')\n    }\n\n    /**\n     * Encode a packet to a Uint8Array.\n     *\n     * @param packet - The packet to encode.\n     * @returns The encoded packet as a Uint8Array.\n     */\n    static encodeBytes(packet: Packet): Uint8Array {\n        const message = trim0x(packet.message)\n        const buffer = Buffer.alloc(MESSAGE_OFFSET + message.length / 2)\n        buffer.writeUInt8(packet.version, PACKET_VERSION_OFFSET)\n        buffer.writeBigUInt64BE(BigInt(packet.nonce), NONCE_OFFSET)\n        buffer.writeUInt32BE(packet.srcEid, SRC_CHAIN_OFFSET)\n        buffer.write(Buffer.from(addressToBytes32(packet.sender)).toString('hex'), SRC_ADDRESS_OFFSET, 32, 'hex')\n        buffer.writeUInt32BE(packet.dstEid, DST_CHAIN_OFFSET)\n        buffer.write(Buffer.from(addressToBytes32(packet.receiver)).toString('hex'), DST_ADDRESS_OFFSET, 32, 'hex')\n        buffer.write(trim0x(packet.guid), GUID_OFFSET, 32, 'hex')\n        buffer.write(message, MESSAGE_OFFSET, message.length / 2, 'hex')\n        return new Uint8Array(buffer)\n    }\n\n    /**\n     * Get the version of the packet.\n     *\n     * @returns The version of the packet.\n     */\n    version(): number {\n        return this.buffer.readUInt8(PACKET_VERSION_OFFSET)\n    }\n\n    /**\n     * Get the nonce of the packet.\n     *\n     * @returns The nonce of the packet as a string.\n     */\n    nonce(): string {\n        return this.buffer.readBigUint64BE(NONCE_OFFSET).toString()\n    }\n\n    /**\n     * Get the source chain ID of the packet.\n     *\n     * @returns The source chain ID of the packet.\n     */\n    srcEid(): number {\n        return this.buffer.readUint32BE(SRC_CHAIN_OFFSET)\n    }\n\n    /**\n     * Get the sender address of the packet.\n     *\n     * @returns The sender address of the packet.\n     */\n    sender(): string {\n        return '0x' + this.buffer.slice(SRC_ADDRESS_OFFSET, DST_CHAIN_OFFSET).toString('hex')\n    }\n\n    /**\n     * Get the sender address in B20 format.\n     *\n     * @returns The sender address in B20 format.\n     */\n    senderAddressB20(): string {\n        return bytes32ToEthAddress(this.sender())\n    }\n\n    /**\n     * Get the destination chain ID of the packet.\n     *\n     * @returns The destination chain ID of the packet.\n     */\n    dstEid(): number {\n        return this.buffer.readUint32BE(DST_CHAIN_OFFSET)\n    }\n\n    /**\n     * Get the receiver address of the packet.\n     *\n     * @returns The receiver address of the packet.\n     */\n    receiver(): string {\n        return '0x' + this.buffer.slice(DST_ADDRESS_OFFSET, GUID_OFFSET).toString('hex')\n    }\n\n    /**\n     * Get the receiver address in B20 format.\n     *\n     * @returns The receiver address in B20 format.\n     */\n    receiverAddressB20(): string {\n        return bytes32ToEthAddress(this.receiver())\n    }\n\n    /**\n     * Get the GUID of the packet.\n     *\n     * @returns The GUID of the packet.\n     */\n    guid(): string {\n        return '0x' + this.buffer.slice(GUID_OFFSET, MESSAGE_OFFSET).toString('hex')\n    }\n\n    /**\n     * Get the message of the packet.\n     *\n     * @returns The message of the packet.\n     */\n    message(): string {\n        return '0x' + this.buffer.slice(MESSAGE_OFFSET).toString('hex')\n    }\n\n    /**\n     * Get the hash of the payload.\n     *\n     * @returns The hash of the payload.\n     */\n    payloadHash(): string {\n        return keccak256(this.payload())\n    }\n\n    /**\n     * Get the payload of the packet.\n     *\n     * @returns The payload of the packet.\n     */\n    payload(): string {\n        return '0x' + this.buffer.slice(GUID_OFFSET).toString('hex')\n    }\n\n    /**\n     * Get the header of the packet.\n     *\n     * @returns The header of the packet.\n     */\n    header(): string {\n        return '0x' + this.buffer.slice(0, GUID_OFFSET).toString('hex')\n    }\n\n    /**\n     * Get the hash of the header.\n     *\n     * @returns The hash of the header.\n     */\n    headerHash(): string {\n        return keccak256(this.header())\n    }\n\n    /**\n     * Deserialize packet from hex string.\n     *\n     * @deprecated Use toPacket instead.\n     * @returns The deserialized packet.\n     */\n    decode(): Packet {\n        return this.toPacket()\n    }\n\n    /**\n     * Convert the encoded data to a Packet object.\n     *\n     * @returns The Packet object.\n     */\n    toPacket(): Packet {\n        return {\n            version: this.version(),\n            nonce: this.nonce(),\n            srcEid: this.srcEid(),\n            sender: this.sender(),\n            dstEid: this.dstEid(),\n            receiver: this.receiver(),\n            guid: this.guid(),\n            message: this.message(),\n            // derived\n            payload: this.payload(),\n        }\n    }\n}\n\n/**\n * Calculate the GUID for a packet header.\n *\n * @param packetHead - The packet header.\n * @returns The calculated GUID.\n */\nexport function calculateGuid(packetHead: PacketHeader): string {\n    return keccak256(\n        solidityPack(\n            ['uint64', 'uint32', 'bytes32', 'uint32', 'bytes32'],\n            [\n                BigNumber.from(packetHead.nonce),\n                packetHead.srcEid,\n                addressToBytes32(packetHead.sender),\n                packetHead.dstEid,\n                addressToBytes32(packetHead.receiver),\n            ]\n        )\n    )\n}\n\nexport { keccak256 } from '@ethersproject/keccak256'\n","import { Packet } from '../model'\n\nimport { PacketV1Codec } from './packet-v1-codec'\n\n/**\n * Serializer for Packet objects.\n */\nexport class PacketSerializer {\n    /**\n     * Serializes a Packet object to a string.\n     *\n     * @param {Packet} packet - The packet to serialize.\n     * @returns {string} The serialized packet as a string.\n     */\n    static serialize(packet: Packet): string {\n        return PacketV1Codec.encode(packet)\n    }\n\n    /**\n     * Serializes a Packet object to a Uint8Array.\n     *\n     * @param {Packet} packet - The packet to serialize.\n     * @returns {Uint8Array} The serialized packet as a Uint8Array.\n     */\n    static serializeBytes(packet: Packet): Uint8Array {\n        return PacketV1Codec.encodeBytes(packet)\n    }\n\n    /**\n     * Deserializes a Uint8Array or string to a Packet object.\n     *\n     * @param {Uint8Array | string} bytesLike - The bytes or string to deserialize.\n     * @returns {Packet} The deserialized Packet object.\n     */\n    static deserialize(bytesLike: Uint8Array | string): Packet {\n        let codec: PacketV1Codec\n        if (bytesLike instanceof Uint8Array) {\n            codec = PacketV1Codec.fromBytes(bytesLike)\n        } else {\n            codec = PacketV1Codec.from(bytesLike)\n        }\n        return codec.toPacket()\n    }\n}\n","/**\n * Abstract class representing a codec.\n */\nabstract class Codec {\n    protected byteLength: number\n\n    /**\n     * Creates an instance of the Codec class.\n     */\n    constructor() {\n        this.byteLength = 0\n    }\n\n    /**\n     * Gets the byte length of the codec.\n     *\n     * @returns {number} The byte length.\n     */\n    getByteLength(): number {\n        return this.byteLength\n    }\n\n    /**\n     * Gets the hex length of the codec.\n     *\n     * @returns {number} The hex length.\n     */\n    getHexLength(): number {\n        return this.byteLength * 2\n    }\n\n    /**\n     * Encodes the codec to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    abstract encode(): string\n\n    /**\n     * Decodes a hex string to a codec.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @returns {Codec} The decoded codec.\n     * @throws {Error} If the method is not implemented.\n     */\n    static decode(hex: string): Codec {\n        throw new Error('Not implemented')\n    }\n}\n\n/**\n * Enum representing the timestamp block configuration.\n */\nexport enum TimestampBlockConfiguration {\n    /**\n     * Represents a timestamp.\n     */\n    Timestamp = 0,\n\n    /**\n     * Represents a block number.\n     */\n    BlockNumber = 1,\n}\n\n/**\n * Enum representing the resolver type.\n */\nexport enum ResolverType {\n    /**\n     * Represents a single view function EVM call.\n     */\n    SingleViewFunctionEVMCall = 1,\n}\n\n/**\n * Enum representing the compute setting.\n */\nexport enum ComputeSetting {\n    /**\n     * Only map.\n     */\n    OnlyMap = 0,\n\n    /**\n     * Only reduce.\n     */\n    OnlyReduce = 1,\n\n    /**\n     * Map and reduce.\n     */\n    MapReduce = 2,\n}\n\n/**\n * Enum representing the compute type.\n */\nexport enum ComputeType {\n    /**\n     * Represents a single view function EVM call.\n     */\n    SingleViewFunctionEVMCall = 1,\n}\n\n/**\n * Interface representing an EVM timestamp.\n */\nexport interface EVMTimestamp {\n    /**\n     * The timestamp.\n     */\n    timestamp: bigint // 8 bytes (if timestampBlockFlag indicates Unix timestamp)\n}\n\n/**\n * Interface representing an EVM block.\n */\nexport interface EVMBlock {\n    /**\n     * The block number.\n     */\n    blockNumber: bigint // 8 bytes (if timestampBlockFlag indicates block number)\n}\n\n/**\n * Interface representing a command request.\n * @see {@link Codec}\n */\nexport interface CommandRequest extends Codec {\n    /**\n     * The request header.\n     */\n    requestHeader: RequestHeader\n}\n\n/**\n * Interface representing a compute.\n * @see {@link Codec}\n */\nexport interface Compute extends Codec {\n    /**\n     * The compute header.\n     */\n    computeHeader: ComputeHeader\n}\n\n/**\n * Class representing a header.\n * @see {@link Codec}\n */\nexport class Header extends Codec {\n    globalVersion: number // 2 bytes\n    appCommandLabel: string // 2 bytes\n    requestCount: number // 2 bytes\n\n    private static GLOBAL_VERSION_BYTES = 2\n    private static APP_COMMAND_LABEL_BYTES = 2\n    private static REQUEST_COUNT_BYTES = 2\n\n    /**\n     * Creates an instance of the Header class.\n     *\n     * @param {number} globalVersion - The global version.\n     * @param {string} appCommandLabel - The application command label.\n     * @param {number} requestCount - The number of requests.\n     */\n    constructor(globalVersion: number, appCommandLabel: string, requestCount: number) {\n        super()\n        this.globalVersion = globalVersion\n        this.appCommandLabel = appCommandLabel\n        this.requestCount = requestCount\n        this.byteLength = Header.GLOBAL_VERSION_BYTES + Header.APP_COMMAND_LABEL_BYTES + Header.REQUEST_COUNT_BYTES\n    }\n\n    /**\n     * Encodes the header to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    encode(): string {\n        const globalVersionHex = numberToHex(this.globalVersion, Header.GLOBAL_VERSION_BYTES) // 2 bytes\n        const appCommandLabelHex = this.appCommandLabel.padStart(bytesToHexLength(Header.APP_COMMAND_LABEL_BYTES), '0')\n        const requestCountHex = numberToHex(this.requestCount, Header.REQUEST_COUNT_BYTES) // 2 bytes\n        return globalVersionHex + appCommandLabelHex + requestCountHex\n    }\n\n    /**\n     * Decodes a hex string to a header.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset] - The offset to start decoding from.\n     * @returns {Header} The decoded header.\n     */\n    static decode(hex: string, offset?: number): Header {\n        let internalOffset = offset ?? 0\n        const globalVersion = hexToNumber(sliceHex(hex, internalOffset, Header.GLOBAL_VERSION_BYTES)) // 2 bytes\n        internalOffset += bytesToHexLength(Header.GLOBAL_VERSION_BYTES)\n        const appCommandLabel = sliceHex(hex, internalOffset, Header.APP_COMMAND_LABEL_BYTES) // 2 bytes\n        internalOffset += bytesToHexLength(Header.APP_COMMAND_LABEL_BYTES)\n        const requestCount = hexToNumber(sliceHex(hex, internalOffset, Header.REQUEST_COUNT_BYTES)) // 2 bytes\n        return new Header(globalVersion, appCommandLabel, requestCount)\n    }\n}\n\n/**\n * Class representing a request header.\n * @see {@link Codec}\n */\nexport class RequestHeader extends Codec {\n    requestVersion: number // 1 byte\n    appRequestLabel: string // 2 bytes (hex or string)\n    resolverType: ResolverType // 2 bytes\n    requestSize: number // 2 bytes\n\n    private static REQUEST_VERSION_BYTES = 1\n    private static APP_REQUEST_LABEL_BYTES = 2\n    private static RESOLVER_TYPE_BYTES = 2\n    private static REQUEST_SIZE_BYTES = 2\n\n    /**\n     * Creates an instance of the RequestHeader class.\n     *\n     * @param {number} requestVersion - The request version.\n     * @param {string} appRequestLabel - The application request label.\n     * @param {ResolverType} resolverType - The resolver type.\n     * @param {number} requestSize - The request size.\n     */\n    constructor(requestVersion: number, appRequestLabel: string, resolverType: ResolverType, requestSize: number) {\n        super()\n        this.requestVersion = requestVersion\n        this.appRequestLabel = appRequestLabel\n        this.resolverType = resolverType\n        this.requestSize = requestSize\n\n        this.byteLength =\n            RequestHeader.REQUEST_VERSION_BYTES +\n            RequestHeader.APP_REQUEST_LABEL_BYTES +\n            RequestHeader.RESOLVER_TYPE_BYTES +\n            RequestHeader.REQUEST_SIZE_BYTES\n    }\n\n    /**\n     * Encodes the request header to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    encode(): string {\n        const requestVersionHex = numberToHex(this.requestVersion, RequestHeader.REQUEST_VERSION_BYTES)\n        const appRequestLabelHex = this.appRequestLabel.padStart(\n            bytesToHexLength(RequestHeader.APP_REQUEST_LABEL_BYTES),\n            '0'\n        )\n        const resolverTypeHex = numberToHex(this.resolverType, RequestHeader.RESOLVER_TYPE_BYTES)\n        const requestSizeHex = numberToHex(this.requestSize, RequestHeader.REQUEST_SIZE_BYTES)\n        return requestVersionHex + appRequestLabelHex + resolverTypeHex + requestSizeHex\n    }\n\n    /**\n     * Decodes a hex string to a request header.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset] - The offset to start decoding from.\n     * @returns {RequestHeader} The decoded request header.\n     */\n    static decode(hex: string, offset?: number): RequestHeader {\n        let internalOffset = offset ?? 0\n        const requestVersion = hexToNumber(sliceHex(hex, internalOffset, RequestHeader.REQUEST_VERSION_BYTES))\n        internalOffset += bytesToHexLength(RequestHeader.REQUEST_VERSION_BYTES)\n        const appRequestLabel = sliceHex(hex, internalOffset, RequestHeader.APP_REQUEST_LABEL_BYTES)\n        internalOffset += bytesToHexLength(RequestHeader.APP_REQUEST_LABEL_BYTES)\n        const resolverType = hexToNumber(sliceHex(hex, internalOffset, RequestHeader.RESOLVER_TYPE_BYTES))\n        internalOffset += bytesToHexLength(RequestHeader.RESOLVER_TYPE_BYTES)\n        const requestSize = hexToNumber(sliceHex(hex, internalOffset, RequestHeader.REQUEST_SIZE_BYTES))\n        return new RequestHeader(requestVersion, appRequestLabel, resolverType, requestSize)\n    }\n}\n\n/**\n * Class representing an EVM base.\n * @see {@link Codec}\n */\nexport class EVMBase extends Codec {\n    targetEid: number // 4 bytes\n    timestampBlockFlag: TimestampBlockConfiguration // 1 byte\n    blockConfirmations: number // 2 bytes\n    to: string // 20 bytes (hex or string)\n    timestamp?: bigint // 8 bytes (if timestampBlockFlag indicates Unix timestamp)\n    blockNumber?: bigint // 8 bytes (if timestampBlockFlag indicates block number)\n\n    private static TARGET_EID_BYTES = 4\n    private static TIMESTAMP_BLOCK_FLAG_BYTES = 1\n    private static BLOCK_CONFIRMATIONS_BYTES = 2\n    private static TO_BYTES = 20\n    private static TIMESTAMP_BYTES = 8\n    private static BLOCK_NUMBER_BYTES = 8\n\n    /**\n     * Creates an instance of the EVMBase class.\n     *\n     * @param {number} targetEid - The target endpoint ID.\n     * @param {TimestampBlockConfiguration} timestampBlockFlag - The timestamp block configuration.\n     * @param {number} blockConfirmations - The number of block confirmations.\n     * @param {string} to - The recipient address.\n     * @param {bigint} [timestamp] - The timestamp.\n     * @param {bigint} [blockNumber] - The block number.\n     */\n    protected constructor(\n        targetEid: number,\n        timestampBlockFlag: TimestampBlockConfiguration,\n        blockConfirmations: number,\n        to: string,\n        timestamp?: bigint,\n        blockNumber?: bigint\n    ) {\n        super()\n        this.targetEid = targetEid\n        this.timestampBlockFlag = timestampBlockFlag\n        this.blockConfirmations = blockConfirmations\n        this.to = to\n        this.timestamp = timestamp\n        this.blockNumber = blockNumber\n        this.byteLength =\n            EVMBase.TARGET_EID_BYTES +\n            EVMBase.TIMESTAMP_BLOCK_FLAG_BYTES +\n            EVMBase.BLOCK_CONFIRMATIONS_BYTES +\n            EVMBase.TO_BYTES +\n            (timestamp !== undefined ? EVMBase.TIMESTAMP_BYTES : 0) +\n            (blockNumber !== undefined ? EVMBase.BLOCK_NUMBER_BYTES : 0)\n    }\n\n    /**\n     * Encodes the EVM base to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    encode(): string {\n        const targetEidHex = numberToHex(this.targetEid, EVMBase.TARGET_EID_BYTES) // 4 bytes\n        const timestampBlockFlagHex = numberToHex(this.timestampBlockFlag, EVMBase.TIMESTAMP_BLOCK_FLAG_BYTES) // 1 byte\n        const blockNumberHex =\n            this.blockNumber !== undefined ? bigIntToHex(this.blockNumber, EVMBase.BLOCK_NUMBER_BYTES) : undefined\n        const timestampHex =\n            this.timestamp !== undefined ? bigIntToHex(this.timestamp, EVMBase.TIMESTAMP_BYTES) : undefined\n\n        if (timestampHex !== undefined && blockNumberHex !== undefined) {\n            throw new Error('Cannot have both timestamp and block number')\n        }\n        const blockConfirmationsHex = numberToHex(this.blockConfirmations, EVMBase.BLOCK_CONFIRMATIONS_BYTES) // 2 bytes\n        const toHex = this.to.padStart(bytesToHexLength(EVMBase.TO_BYTES), '0') // 20 bytes (hex or string)\n\n        const blockOrTimestampHex = blockNumberHex ?? timestampHex\n        if (blockOrTimestampHex === undefined) {\n            throw new Error('Either block number or timestamp must be set')\n        }\n        return targetEidHex + timestampBlockFlagHex + blockOrTimestampHex + blockConfirmationsHex + toHex\n    }\n\n    /**\n     * Decodes a hex string to an EVM base.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset] - The offset to start decoding from.\n     * @returns {EVMBase} The decoded EVM base.\n     */\n    static decode(hex: string, offset?: number): EVMBase {\n        let internalOffset = offset ?? 0\n        const targetEid = hexToNumber(sliceHex(hex, internalOffset, EVMBase.TARGET_EID_BYTES)) // 4 bytes\n        internalOffset += bytesToHexLength(EVMBase.TARGET_EID_BYTES)\n\n        const timestampBlockFlag: TimestampBlockConfiguration = hexToNumber(\n            sliceHex(hex, internalOffset, EVMBase.TIMESTAMP_BLOCK_FLAG_BYTES)\n        )\n        internalOffset += bytesToHexLength(EVMBase.TIMESTAMP_BLOCK_FLAG_BYTES)\n\n        let timestamp: bigint | undefined\n        let blockNumber: bigint | undefined\n        if (timestampBlockFlag === TimestampBlockConfiguration.Timestamp) {\n            timestamp = hexToBigInt(sliceHex(hex, internalOffset, EVMBase.TIMESTAMP_BYTES)) // 8 bytes\n            internalOffset += bytesToHexLength(EVMBase.TIMESTAMP_BYTES)\n        } else {\n            blockNumber = hexToBigInt(sliceHex(hex, internalOffset, EVMBase.BLOCK_NUMBER_BYTES)) // 8 bytes\n            internalOffset += bytesToHexLength(EVMBase.BLOCK_NUMBER_BYTES)\n        }\n\n        const blockConfirmations = hexToNumber(sliceHex(hex, internalOffset, EVMBase.BLOCK_CONFIRMATIONS_BYTES)) // 2 bytes\n        internalOffset += bytesToHexLength(EVMBase.BLOCK_CONFIRMATIONS_BYTES)\n        const to = sliceHex(hex, internalOffset, EVMBase.TO_BYTES) // 20 bytes\n\n        return new EVMBase(targetEid, timestampBlockFlag, blockConfirmations, to, timestamp, blockNumber)\n    }\n}\n\n/**\n * Class representing a single view function EVM call.\n * @see {@link EVMBase}, {@link CommandRequest}\n */\nexport class SingleViewFunctionEVMCall extends EVMBase implements CommandRequest {\n    requestHeader: RequestHeader\n    calldata: string // Calldata (size specified by calldataSize)\n\n    /**\n     * Creates an instance of the SingleViewFunctionEVMCall class.\n     *\n     * @param {RequestHeader} requestHeader - The request header.\n     * @param {number} targetEid - The target endpoint ID.\n     * @param {TimestampBlockConfiguration} timestampBlockFlag - The timestamp block configuration.\n     * @param {number} blockConfirmations - The number of block confirmations.\n     * @param {string} to - The recipient address.\n     * @param {string} calldata - The calldata.\n     * @param {bigint} [timestamp] - The timestamp.\n     * @param {bigint} [blockNumber] - The block number.\n     */\n    constructor(\n        requestHeader: RequestHeader,\n        targetEid: number,\n        timestampBlockFlag: TimestampBlockConfiguration,\n        blockConfirmations: number,\n        to: string,\n        calldata: string,\n        timestamp?: bigint,\n        blockNumber?: bigint\n    ) {\n        super(targetEid, timestampBlockFlag, blockConfirmations, to, timestamp, blockNumber)\n        this.requestHeader = requestHeader\n        this.calldata = calldata\n        const evmByteLength = super.getByteLength()\n        const callDataSize = this.requestHeader.requestSize - evmByteLength\n        this.byteLength = this.requestHeader.getByteLength() + evmByteLength + callDataSize\n    }\n\n    /**\n     * Encodes the single view function EVM call to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    encode(): string {\n        const requestHeaderHex = this.requestHeader.encode() // Encodes the request header from CommandRequest\n        const evmBaseHex = super.encode() // Encodes the EVMBase fields\n        const callDataSize = this.requestHeader.requestSize - super.getByteLength()\n        const calldataHex = this.calldata.padStart(callDataSize * 2, '0') // Calldata (hex string)\n\n        return requestHeaderHex + evmBaseHex + calldataHex\n    }\n\n    /**\n     * Decodes a hex string to a single view function EVM call.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset] - The offset to start decoding from.\n     * @returns {SingleViewFunctionEVMCall} The decoded single view function EVM call.\n     */\n    static decode(hex: string, offset?: number): SingleViewFunctionEVMCall {\n        let internalOffset = offset ?? 0\n        const requestHeader = RequestHeader.decode(hex, internalOffset) // Decodes the CommandRequest\n        internalOffset += requestHeader.getHexLength()\n        const evmBase = super.decode(hex, internalOffset) // Decodes the EVMBase\n        internalOffset += evmBase.getHexLength()\n        const calldataSize = requestHeader.requestSize - evmBase.getByteLength()\n        const calldata = sliceHex(hex, internalOffset, calldataSize)\n        return new SingleViewFunctionEVMCall(\n            requestHeader,\n            evmBase.targetEid,\n            evmBase.timestampBlockFlag,\n            evmBase.blockConfirmations,\n            evmBase.to,\n            calldata,\n            evmBase.timestamp,\n            evmBase.blockNumber\n        )\n    }\n}\n\n/**\n * Class representing a compute header.\n * @see {@link Codec}\n */\nexport class ComputeHeader extends Codec {\n    computeVersion: number // 1 byte\n    computeType: ComputeType // 2 bytes\n    computeSetting: ComputeSetting // 1 byte\n\n    private static COMPUTE_VERSION_BYTES = 1\n    private static COMPUTE_TYPE_BYTES = 2\n    private static COMPUTE_SETTING_BYTES = 1\n\n    /**\n     * Creates an instance of the ComputeHeader class.\n     *\n     * @param {number} computeVersion - The compute version.\n     * @param {ComputeType} computeType - The compute type.\n     * @param {ComputeSetting} computeSetting - The compute setting.\n     */\n    constructor(computeVersion: number, computeType: ComputeType, computeSetting: ComputeSetting) {\n        super()\n        this.computeVersion = computeVersion\n        this.computeType = computeType\n        this.computeSetting = computeSetting\n        this.byteLength =\n            ComputeHeader.COMPUTE_VERSION_BYTES + ComputeHeader.COMPUTE_TYPE_BYTES + ComputeHeader.COMPUTE_SETTING_BYTES\n    }\n\n    /**\n     * Encodes the compute header to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    encode(): string {\n        const computeVersionHex = numberToHex(this.computeVersion, ComputeHeader.COMPUTE_VERSION_BYTES)\n        const computeTypeHex = numberToHex(this.computeType, ComputeHeader.COMPUTE_TYPE_BYTES)\n        const computeSettingHex = numberToHex(this.computeSetting, ComputeHeader.COMPUTE_SETTING_BYTES)\n        return computeVersionHex + computeTypeHex + computeSettingHex\n    }\n\n    /**\n     * Decodes a hex string to a compute header.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset] - The offset to start decoding from.\n     * @returns {ComputeHeader} The decoded compute header.\n     */\n    static decode(hex: string, offset?: number): ComputeHeader {\n        let internalOffset = offset ?? 0\n        const computeVersion = hexToNumber(sliceHex(hex, internalOffset, ComputeHeader.COMPUTE_VERSION_BYTES))\n        internalOffset += bytesToHexLength(ComputeHeader.COMPUTE_VERSION_BYTES)\n        const computeType = hexToNumber(sliceHex(hex, internalOffset, ComputeHeader.COMPUTE_TYPE_BYTES))\n        internalOffset += bytesToHexLength(ComputeHeader.COMPUTE_TYPE_BYTES)\n        const computeSetting = hexToNumber(sliceHex(hex, internalOffset, ComputeHeader.COMPUTE_SETTING_BYTES))\n        return new ComputeHeader(computeVersion, computeType, computeSetting)\n    }\n}\n\n/**\n * Class representing a compute EVM.\n * @see {@link EVMBase}, {@link Compute}\n */\nexport class ComputeEVM extends EVMBase implements Compute {\n    computeHeader: ComputeHeader\n\n    /**\n     * Creates an instance of the ComputeEVM class.\n     *\n     * @param {ComputeHeader} computeHeader - The compute header.\n     * @param {number} targetEid - The target endpoint ID.\n     * @param {TimestampBlockConfiguration} timestampBlockFlag - The timestamp block configuration.\n     * @param {number} blockConfirmations - The number of block confirmations.\n     * @param {string} to - The recipient address.\n     * @param {bigint} [timestamp] - The timestamp.\n     * @param {bigint} [blockNumber] - The block number.\n     */\n    constructor(\n        computeHeader: ComputeHeader,\n        targetEid: number,\n        timestampBlockFlag: TimestampBlockConfiguration,\n        blockConfirmations: number,\n        to: string,\n        timestamp?: bigint,\n        blockNumber?: bigint\n    ) {\n        super(targetEid, timestampBlockFlag, blockConfirmations, to, timestamp, blockNumber)\n        this.computeHeader = computeHeader\n        const evmByteLength = super.getByteLength()\n        this.byteLength += evmByteLength + this.computeHeader.getByteLength()\n    }\n\n    /**\n     * Encodes the compute EVM to a hex string.\n     *\n     * @returns {string} The encoded hex string.\n     */\n    encode(): string {\n        const computeHeaderHex = this.computeHeader.encode() // Encodes the ComputeHeader fields\n        const evmBaseHex = super.encode() // Encodes the EVMBase fields\n        return computeHeaderHex + evmBaseHex\n    }\n\n    /**\n     * Decodes a hex string to a compute EVM.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset] - The offset to start decoding from.\n     * @returns {ComputeEVM} The decoded compute EVM.\n     */\n    static decode(hex: string, offset?: number): ComputeEVM {\n        let internalOffset = offset ?? 0\n        const computeHeader = ComputeHeader.decode(hex, internalOffset) // Decodes the ComputeHeader\n        internalOffset += computeHeader.getHexLength()\n        const evmBase = EVMBase.decode(hex, internalOffset) // Decodes the EVMBase part\n        internalOffset += evmBase.getHexLength()\n\n        return new ComputeEVM(\n            computeHeader,\n            evmBase.targetEid,\n            evmBase.timestampBlockFlag,\n            evmBase.blockConfirmations,\n            evmBase.to,\n            evmBase.timestamp,\n            evmBase.blockNumber\n        )\n    }\n}\n\n/**\n * Class representing a command.\n * @see {@link Codec}\n */\nexport class Command extends Codec {\n    header: Header\n    requests: CommandRequest[]\n    compute?: Compute\n\n    /**\n     * Creates an instance of the Command class.\n     *\n     * @param {Header} header - The command header.\n     * @param {CommandRequest[]} requests - The command requests.\n     * @param {Compute} [compute] - The compute object.\n     */\n    constructor(header: Header, requests: CommandRequest[], compute?: Compute) {\n        super()\n        this.header = header\n        this.requests = requests\n        this.compute = compute\n        this.byteLength =\n            this.header.getByteLength() +\n            this.requests.reduce((acc, req) => acc + req.getByteLength(), 0) +\n            (this.compute ? this.compute.getByteLength() : 0)\n    }\n\n    /**\n     * Encodes a command request.\n     *\n     * @param {CommandRequest} request - The command request to encode.\n     * @returns {string} The encoded command request.\n     * @throws {Error} If the resolver type is invalid.\n     */\n    private encodeCommandRequest(request: CommandRequest): string {\n        switch (request.requestHeader.resolverType) {\n            case ResolverType.SingleViewFunctionEVMCall:\n                return (request as SingleViewFunctionEVMCall).encode()\n            default:\n                throw new Error('Invalid resolver type')\n        }\n    }\n\n    /**\n     * Encodes the compute object.\n     *\n     * @returns {string} The encoded compute object.\n     * @throws {Error} If the compute type is invalid.\n     */\n    private encodeCompute(): string {\n        if (!this.compute) {\n            return ''\n        }\n        switch (this.compute.computeHeader.computeType) {\n            case ComputeType.SingleViewFunctionEVMCall:\n                return (this.compute as ComputeEVM).encode()\n            default:\n                throw new Error('Invalid compute type')\n        }\n    }\n\n    /**\n     * Encodes the command.\n     *\n     * @returns {string} The encoded command.\n     */\n    encode(): string {\n        const headerHex = this.header.encode()\n        const requestsHex = this.requests.map((req) => this.encodeCommandRequest(req)).join('')\n        const computeHex = this.encodeCompute()\n        return headerHex + requestsHex + computeHex\n    }\n\n    /**\n     * Decodes a command request.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} offset - The offset to start decoding from.\n     * @returns {CommandRequest} The decoded command request.\n     * @throws {Error} If the resolver type is invalid.\n     */\n    private static decodeRequest(hex: string, offset: number): CommandRequest {\n        const requestHeader = RequestHeader.decode(hex, offset)\n        switch (requestHeader.resolverType) {\n            case ResolverType.SingleViewFunctionEVMCall:\n                return SingleViewFunctionEVMCall.decode(hex, offset)\n            default:\n                throw new Error('Invalid resolver type')\n        }\n    }\n\n    /**\n     * Decodes the compute object.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} offset - The offset to start decoding from.\n     * @returns {Compute} The decoded compute object.\n     * @throws {Error} If the compute type is invalid.\n     */\n    private static decodeCompute(hex: string, offset: number): Compute {\n        const computeHeader = ComputeHeader.decode(hex, offset)\n\n        switch (computeHeader.computeType) {\n            case ComputeType.SingleViewFunctionEVMCall:\n                return ComputeEVM.decode(hex, offset)\n            default:\n                throw new Error('Invalid compute type')\n        }\n    }\n\n    /**\n     * Decodes a command.\n     *\n     * @param {string} hex - The hex string to decode.\n     * @param {number} [offset=0] - The offset to start decoding from.\n     * @returns {Command} The decoded command.\n     */\n    static decode(hex: string, offset?: number): Command {\n        let internalOffset = offset ?? 0\n        const header = Header.decode(hex, internalOffset)\n        internalOffset += header.getHexLength()\n\n        const requests: CommandRequest[] = []\n        for (let i = 0; i < header.requestCount; i++) {\n            const request = Command.decodeRequest(hex, internalOffset)\n            requests.push(request)\n            internalOffset += request.getHexLength()\n        }\n\n        const command =\n            internalOffset === hex.length\n                ? new Command(header, requests)\n                : new Command(header, requests, Command.decodeCompute(hex, internalOffset))\n\n        return command\n    }\n}\n\n/**\n * Converts bytes to hex length.\n *\n * @param {number} bytes - The number of bytes.\n * @returns {number} The hex length.\n */\nfunction bytesToHexLength(bytes: number): number {\n    return bytes * 2\n}\n\n/**\n * Slices a hex string.\n *\n * @param {string} hex - The hex string to slice.\n * @param {number} offset - The offset to start slicing from.\n * @param {number} bytes - The number of bytes to slice.\n * @returns {string} The sliced hex string.\n */\nfunction sliceHex(hex: string, offset: number, bytes: number): string {\n    const length = bytesToHexLength(bytes) // Convert bytes to hex characters\n    const slice = hex.slice(offset, offset + length)\n    return slice\n}\n\n/**\n * Converts a hex string to a number.\n *\n * @param {string} hexStr - The hex string to convert.\n * @returns {number} The converted number.\n */\nfunction hexToNumber(hexStr: string): number {\n    return parseInt(hexStr, 16)\n}\n\n/**\n * Converts a hex string to a bigint.\n *\n * @param {string} hexStr - The hex string to convert.\n * @returns {bigint} The converted bigint.\n */\nfunction hexToBigInt(hexStr: string): bigint {\n    return BigInt(`0x${hexStr}`)\n}\n\n/**\n * Converts a number to a hex string.\n *\n * @param {number} num - The number to convert.\n * @param {number} bytes - The number of bytes.\n * @returns {string} The converted hex string.\n */\nfunction numberToHex(num: number, bytes: number): string {\n    return num.toString(16).padStart(bytes * 2, '0') // Ensure it has the correct byte size in hex\n}\n\n/**\n * Converts a bigint to a hex string.\n *\n * @param {bigint} bigInt - The bigint to convert.\n * @param {number} bytes - The number of bytes.\n * @returns {string} The converted hex string.\n */\nfunction bigIntToHex(bigInt: bigint, bytes: number): string {\n    return bigInt.toString(16).padStart(bytes * 2, '0')\n}\n"]}